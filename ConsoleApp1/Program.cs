internal class Program
{
    /*
    Запустите для пошаговой демонстрации алгоритмов на примере тестового массива
    */
    private static void Main(string[] args)
    {
        int[] worst = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        Write(worst);

        Console.WriteLine("Bubble");
        BubbleSort(worst.Clone() as int[]);
        Console.WriteLine();

        Console.WriteLine("Insertion");
        InsertionSort(worst.Clone() as int[]);
        Console.WriteLine();

        Console.WriteLine("Selection");
        SelectionSort(worst.Clone() as int[]);
        Console.WriteLine();

        Console.WriteLine("Merge");
        int[] worst2 = worst.Clone() as int[];
        MergeSort(worst2);
        Write(worst2);
        Console.WriteLine();

    }

    /*
    Пузырьковая сортировка — это простой алгоритм сортировки, который работает путем многократной замены соседних элементов, если они расположены в неправильном порядке. 
    Он получил свое название потому, что на каждой итерации самый большой элемент «всплывает» на свое правильное место. Этот процесс замены продолжается до тех пор, пока весь список 
    не будет отсортирован в порядке возрастания. Основные шаги алгоритма таковы: начиная с начала списка, сравнивайте каждую пару соседних элементов и меняйте их местами, 
    если они расположены в неправильном порядке, а затем проходите по списку до тех пор, пока замены не перестанут нужны. Однако, несмотря на свою простоту, 
    пузырьковая сортировка не подходит для больших наборов данных, поскольку ее наихудшая и средняя временная сложность равна O(n²), где n — количество сортируемых элементов.
    */
    private static int[] BubbleSort(int[] arr, int step = 0)
    {
        for (int i = arr.Length; i >= 0; i--)
        {
            for (int j = 1; j < i; j++)
            {
                if (arr[j - 1] > arr[j])
                    (arr[j - 1], arr[j]) = (arr[j], arr[j - 1]);

                Write(arr, $"(i = {i}, j = {j}, step = {++step})");
            }
        }

        return arr;
    }

    /*
    Сортировка вставками — это простой алгоритм сортировки, который создает окончательный отсортированный массив (или список) по одному элементу за раз. 
    Для больших списков он гораздо менее эффективен, чем более продвинутые алгоритмы, такие как быстрая сортировка, пирамидальная сортировка или сортировка слиянием. 
    Тем не менее, он дает несколько преимуществ, таких как простота понимания алгоритма, он хорошо работает с небольшими списками или списками, которые уже частично отсортированы, 
    и может сортировать список по мере его получения. Алгоритм выполняет итерацию, потребляя один входной элемент при каждом повторении и увеличивая отсортированный выходной список. 
    На каждой итерации он удаляет один элемент из входных данных, находит место, которому он принадлежит, в отсортированном списке и вставляет его туда. Это повторяется до тех пор,
    пока не останется ни одного входного элемента.
    */
    private static int[] InsertionSort(int[] arr, int step = 0)
    {
        for (int i = 0; i < arr.Length - 1; i++)
        {
            for (int j = i + 1; j > 0; j--)
            {
                if (arr[j - 1] > arr[j])
                {
                    (arr[j - 1], arr[j]) = (arr[j], arr[j - 1]);
                    Write(arr, $"(i = {i}, j = {j}), step = {++step}");
                }
                else
                {
                    break;
                }
            }
        }

        return arr;
    }


    /*
    Сортировка выбором — это простой и интуитивно понятный алгоритм сортировки. Он работает путем деления массива на две части — отсортированную и несортированную. 
    Изначально отсортированная часть пуста, а несортированная часть содержит все элементы. Алгоритм многократно выбирает наименьший (или наибольший, если сортировка по убыванию) 
    элемент из несортированной части и перемещает его в конец отсортированной части. Процесс продолжается до тех пор, пока несортированная часть не станет пустой, 
    а отсортированная часть не будет содержать все элементы. Сортировка выбором неэффективна для больших списков, так как ее временная сложность равна O(n²), 
    где n — количество элементов.
    */
    private static int[] SelectionSort(int[] arr, int step = 0)
    {
        int length = arr.Length;

        for (int i = 0; i < length; i++)
        {
            int minIndex = i;

            for (int j = i + 1; j < length; j++)
            {
                if (arr[minIndex] > arr[j])
                    minIndex = j;
            }

            if (i != minIndex)
                (arr[minIndex], arr[i]) = (arr[i], arr[minIndex]);

            Write(arr, $"(i = {i}), step = {++step}");
        }

        return arr;
    }

    /*
   Сортировка слиянием — это тип алгоритма сортировки, который следует парадигме «разделяй и властвуй». Он был изобретен Джоном фон Нейманом в 1945 году. 
   Этот алгоритм работает путем деления несортированного списка на n разделов, каждый из которых содержит один элемент (список из одного элемента считается отсортированным), 
   а затем многократного слияния разделов для создания новых отсортированных списков, пока не останется только 1 отсортированный список. Этот результирующий список 
   является полностью отсортированным списком. Процесс деления списка выполняется рекурсивно, пока он не достигнет базового случая списка с одним элементом.
   Сортировка слиянием имеет временную сложность O(n log n) для всех случаев (наилучшего, среднего и наихудшего), что делает ее высокоэффективной для больших наборов данных.
   */
    private static void MergeSort(int[] arr, int step = 0)
    {
        step++;

        if (arr.Length <= 1)
        {
            Write(arr, $"step = {step}");
            return;
        }

        int mid = arr.Length / 2;

        int[] left = new int[mid];
        int[] right = new int[arr.Length - mid];

        for (int i = 0; i < mid; i++)
            left[i] = arr[i];

        for (int i = mid; i < arr.Length; i++)
            right[i - mid] = arr[i];

        MergeSort(left, step);
        MergeSort(right, step);

        Merge(arr, left, right);

        Write(arr, $"step = {step}");
    }

    private static void Merge(int[] arr, int[] left, int[] right)
    {
        int i = 0, j = 0, k = 0;

        while (i < left.Length && j < right.Length)
        {
            if (left[i] <= right[j])
            {
                arr[k] = left[i];
                i++;
            }
            else
            {
                arr[k] = right[j];
                j++;
            }

            k++;
        }

        while (i < left.Length)
        {
            arr[k] = left[i];
            i++;
            k++;
        }

        while (j < right.Length)
        {
            arr[k] = right[j];
            j++;
            k++;
        }
    }


    public static void Write(int[] arr, string stat = "")
    {
        Console.Write('[');

        for (int i = 0; i < arr.Length; i++)
        {
            int curr = arr[i];
            Console.Write(curr);
            if (i != arr.Length - 1)
                Console.Write(", ");
        }

        Console.Write(']');
        Console.Write(' ');
        Console.Write(stat);
        Console.WriteLine();
    }

}