internal class Program
{
    /*
    Запустите для пошаговой демонстрации алгоритмов на примере тестового массива
    */
    private static void Main(string[] args)
    {
        int[] arr = [7, 4, 9, 1, 10, 5, 6, 2, 3, 0, 8];
        Write(arr);

        Console.WriteLine("Bubble");
        BubbleSort([.. arr]);
        Console.WriteLine();

        Console.WriteLine("Insertion");
        InsertionSort([.. arr]);
        Console.WriteLine();

        Console.WriteLine("Selection");
        SelectionSort([.. arr]);
        Console.WriteLine();

        Console.WriteLine("Merge");
        MergeSort([.. arr]);
        Console.WriteLine();

        Console.WriteLine("Quick");
        QuickSort([.. arr]);
        Console.WriteLine();

        Console.WriteLine("Heap");
        HeapSort.Sort([.. arr]);
        Console.WriteLine();
    }

    /*
    Пузырьковая сортировка — это простой алгоритм сортировки, который работает путем многократной замены соседних элементов, если они расположены в неправильном порядке. 
    Он получил свое название потому, что на каждой итерации самый большой элемент «всплывает» на свое правильное место. Этот процесс замены продолжается до тех пор, пока весь список 
    не будет отсортирован в порядке возрастания. Основные шаги алгоритма таковы: начиная с начала списка, сравнивайте каждую пару соседних элементов и меняйте их местами, 
    если они расположены в неправильном порядке, а затем проходите по списку до тех пор, пока замены не перестанут нужны. Однако, несмотря на свою простоту, 
    пузырьковая сортировка не подходит для больших наборов данных, поскольку ее наихудшая и средняя временная сложность равна O(n²), где n — количество сортируемых элементов.
    */
    private static int[] BubbleSort(int[] arr, int step = 0)
    {
        for (int i = arr.Length; i >= 0; i--)
        {
            for (int j = 1; j < i; j++)
            {
                if (arr[j - 1] > arr[j])
                    (arr[j - 1], arr[j]) = (arr[j], arr[j - 1]);

                Write(arr, $"(i = {i}, j = {j}, step = {++step})");
            }
        }

        return arr;
    }

    /*
    Сортировка вставками — это простой алгоритм сортировки, который создает окончательный отсортированный массив (или список) по одному элементу за раз. 
    Для больших списков он гораздо менее эффективен, чем более продвинутые алгоритмы, такие как быстрая сортировка, пирамидальная сортировка или сортировка слиянием. 
    Тем не менее, он дает несколько преимуществ, таких как простота понимания алгоритма, он хорошо работает с небольшими списками или списками, которые уже частично отсортированы, 
    и может сортировать список по мере его получения. Алгоритм выполняет итерацию, потребляя один входной элемент при каждом повторении и увеличивая отсортированный выходной список. 
    На каждой итерации он удаляет один элемент из входных данных, находит место, которому он принадлежит, в отсортированном списке и вставляет его туда. Это повторяется до тех пор,
    пока не останется ни одного входного элемента.
    */
    private static int[] InsertionSort(int[] arr, int step = 0)
    {
        for (int i = 0; i < arr.Length - 1; i++)
        {
            for (int j = i + 1; j > 0; j--)
            {
                if (arr[j - 1] > arr[j])
                {
                    (arr[j - 1], arr[j]) = (arr[j], arr[j - 1]);
                    Write(arr, $"(i = {i}, j = {j}), step = {++step}");
                }
                else
                {
                    break;
                }
            }
        }

        return arr;
    }


    /*
    Сортировка выбором — это простой и интуитивно понятный алгоритм сортировки. Он работает путем деления массива на две части — отсортированную и несортированную. 
    Изначально отсортированная часть пуста, а несортированная часть содержит все элементы. Алгоритм многократно выбирает наименьший (или наибольший, если сортировка по убыванию) 
    элемент из несортированной части и перемещает его в конец отсортированной части. Процесс продолжается до тех пор, пока несортированная часть не станет пустой, 
    а отсортированная часть не будет содержать все элементы. Сортировка выбором неэффективна для больших списков, так как ее временная сложность равна O(n²), 
    где n — количество элементов.
    */
    private static int[] SelectionSort(int[] arr, int step = 0)
    {
        int length = arr.Length;

        for (int i = 0; i < length; i++)
        {
            int minIndex = i;

            for (int j = i + 1; j < length; j++)
            {
                if (arr[minIndex] > arr[j])
                    minIndex = j;
            }

            if (i != minIndex)
                (arr[minIndex], arr[i]) = (arr[i], arr[minIndex]);

            Write(arr, $"(i = {i}), step = {++step}");
        }

        return arr;
    }

    /*
   Сортировка слиянием — это тип алгоритма сортировки, который следует парадигме «разделяй и властвуй». Он был изобретен Джоном фон Нейманом в 1945 году. 
   Этот алгоритм работает путем деления несортированного списка на n разделов, каждый из которых содержит один элемент (список из одного элемента считается отсортированным), 
   а затем многократного слияния разделов для создания новых отсортированных списков, пока не останется только 1 отсортированный список. Этот результирующий список 
   является полностью отсортированным списком. Процесс деления списка выполняется рекурсивно, пока он не достигнет базового случая списка с одним элементом.
   Сортировка слиянием имеет временную сложность O(n log n) для всех случаев (наилучшего, среднего и наихудшего), что делает ее высокоэффективной для больших наборов данных.
   */
    private static void MergeSort(int[] arr, int step = 0)
    {
        step++;

        if (arr.Length <= 1)
        {
            Write(arr, $"step = {step}");
            return;
        }

        int mid = arr.Length / 2;

        int[] left = new int[mid];
        int[] right = new int[arr.Length - mid];

        for (int i = 0; i < mid; i++)
            left[i] = arr[i];

        for (int i = mid; i < arr.Length; i++)
            right[i - mid] = arr[i];

        MergeSort(left, step);
        MergeSort(right, step);

        int y = 0, j = 0, k = 0;

        while (y < left.Length && j < right.Length)
        {
            if (left[y] <= right[j])
            {
                arr[k] = left[y];
                y++;
            }
            else
            {
                arr[k] = right[j];
                j++;
            }

            k++;
        }

        while (y < left.Length)
        {
            arr[k] = left[y];
            y++;
            k++;
        }

        while (j < right.Length)
        {
            arr[k] = right[j];
            j++;
            k++;
        }

        Write(arr, $"step = {step}");
    }

    /*
    Быстрая сортировка, также известная как сортировка с обменом разделами, представляет собой эффективный алгоритм сортировки на месте, в котором используется принцип 
    «разделяй и властвуй». Он был разработан Тони Хоаром в 1959 году. Он действует путем выбора «опорного» элемента из массива и разделения других элементов на два подмассива 
    в зависимости от того, меньше или больше они, чем опорный элемент. Затем подмассивы рекурсивно сортируются. Этот процесс продолжается до тех пор, пока не будет достигнут 
    базовый случай, то есть когда массив или подмассив имеет ноль или один элемент и, следовательно, уже отсортирован. Быстрая сортировка может иметь наихудшую производительность 
    O(n^2), если ведущая точка является наименьшим или самым большим элементом в массиве, хотя этот сценарий встречается редко, если ведущая точка выбирается случайным образом. 
    Средняя временная сложность случая равна O(n log n).
    */
    public static List<int> QuickSort(List<int> arr, int step = 0)
    {
        if (arr.Count < 2)
        {
            return arr;
        }

        step++;
        int pivot = arr.Count / 2;

        List<int> less = [];
        List<int> moreOrEqual = [];

        for (int i = 0; i < arr.Count; i++)
        {
            if (i == pivot)
            {
                continue;
            }
            else if (arr[i] < arr[pivot])
            {
                less.Add(arr[i]);
            }
            else
            {
                moreOrEqual.Add(arr[i]);
            }
        }

        List<int> res = [.. QuickSort(less, step), arr[pivot], .. QuickSort(moreOrEqual, step)];

        Write([.. res], $"step = {step}");


        return res;
    }

    /*
    Heap sort — это алгоритм сортировки, основанный на использовании кучи (heap). Куча — это бинарное дерево, удовлетворяющее свойству кучи: значение каждого узла больше или равно значениям его потомков (для max-кучи).  
    Heap sort работает в два этапа:

    1. Построение кучи:  Преобразование входного массива в max-кучу.
    2. Извлечение элементов: Повторяющееся извлечение максимального элемента (корня кучи) и его размещение в конце отсортированного массива.
    */
    public class HeapSort
    {
        public static void Sort(int[] arr)
        {
            int length = arr.Length;

            //Построение кучи
            for (int i = length / 2 - 1; i >= 0; i--)
            {
                Heapify(arr, length, i);
            }

            //Сортировка, пересоздание кучи с переносом первого (наибольшего) элемента от последнего элемента к второму.
            for (int i = length - 1; i > 0; i--)
            {
                (arr[0], arr[i]) = (arr[i], arr[0]);
                Heapify(arr, i, 0);
            }
        }

        private static void Heapify(int[] arr, int length, int i, int step = 0)
        {
            int largest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;

            if (left < length && arr[left] > arr[largest])
            {
                largest = left;
            }


            if (right < length && arr[right] > arr[largest])
            {
                largest = right;
            }

            if (largest != i)
            {
                (arr[i], arr[largest]) = (arr[largest], arr[i]);
            }

            Write(arr, $"(Построение кучи, i = {i}, шаг {++step}");

            if (largest != i)
            {
                Heapify(arr, length, largest);
            }
        }
    }

    public static void Write(int[] arr, string stat = "")
    {
        Console.Write('[');

        for (int i = 0; i < arr.Length; i++)
        {
            int curr = arr[i];
            Console.Write(curr);
            if (i != arr.Length - 1)
                Console.Write(", ");
        }

        Console.Write(']');
        Console.Write(' ');
        Console.Write(stat);
        Console.WriteLine();
    }

}